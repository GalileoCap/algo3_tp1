Por \'ultimo, en el tercer ejercicio se debe trabajar con una variante del anterior. 
\newline

Vamos a contar con un terreno de $l \cdot w$, siendo nuevamente $l$ el $largo$ y $w$ el $ancho$, pero ahora el planteo del problema es un poco distinto. Se vuelve a tener a disposici\'on una cantidad $n$ de aspersores con su $radio "r"$ y su $posición "pos"$, pero se les agrega un atributo m\'as, su $costo "c"$. Aqu\'i radica la escencia del problema, ya que en vez de tener que encontrar la menor cantidad posible de aspersores que puedan regar todo el terreno, se debe encontrar el conjunto de aspersores que pueda \textbf{cubrir todo el terreno} y que \textbf{su costo total sea el mínimo posible} (entre todos los conjuntos de aspersores que pueden cubrir el jard\'in). Como el algoritmo que emplearemos arroja el m\'inimo costo posible y no el conjunto de aspersores, si hay m\'as de un conjunto de aspersores que cumplan con el m\'inimo costo no altera el resultado final de la funci\'on.
\newline

Para resolver este problema en particular, se tom\'o como t\'ecnica algor\'itmica la \textbf{"Programación Dinámica"}, porque se busc\'o evitar que la funci\'on que soluciona este ejercicio no resuelva el mismo problema varias veces. Si esto ocurriera, se perder\'ia mucho tiempo ejecutando cosas a las cuales ya se le conocen su valor.
\newline

A la hora de plantear el problema, tomamos un camino distinto al de la $resolución golosa$ anteriormente mencionada. En vez de tener una \textbf{cola de prioridad} donde los aspersores est\'an ordenados de mayor a menor seg\'un su prioridad (a menor límite izquierdo, mayor la prioridad), empleamos un \textbf{vector} para posicionarlos. Primero cargamos a los aspersores en este en base a su posici\'on de llegada (es decir, el primero en ser cargado v\'ia consola ir\'a a la primer posicion, el segundo a la segunda, y as\'i hasta el aspersor n\'umero "n"). Una vez que el vector estuvo listo, se lo orden\'o con $mergesort$ (coste \textbf{O(n $\cdot$ log n)}) nuevamente seg\'un su l\'imite izquierdo en el jard\'in. La \'unica diferencia es que ahora, para poder acceder a un aspersor, podemos hacerlo con su \'indice en \textbf{O(1)} sin alterar las propiedades del vector, mientras que con la cola de prioridad, s\'i o s\'i deber\'iamos desencolar sus elementos para llegar a determinada posici\'on i, con i \in \lbrace 1,... ,|cola| \rbrace.
\newline

Con nuestro conjunto ordenado de aspersores ya conocido, llam\'emoslo $\mathbb{A}$, donde $a_i$ es el $i\'esimo$ aspersor, especificamos el problema. Se busca encontrar la soluci\'on X tal que $X \subset \mathbb{A}$ y X riega todo el jard\'in y $\forall Y \subset \mathbb{A}$ que riegue todo el jard\'in, $costeTotal(Y) = \sum_{i=1}^{|Y|}costo(y_{i}) \geq \sum_{i=1}^{|X|}costo(x_{i}) = costeTotal(X)$. Veamos c\'omo es la funci\'on que resuelve esta problem\'atica.
\newline

Se llama $\textbf{f(i,j) = costeTotal(X)}$. Tener en cuenta que, para todas las funciones a continuaci\'on con los parametros $i,j$, estos corresponden al $i\'esimo$ y $j\'esimo$ aspersor respectivamente. Y adem\'as, el $aspersor_i$ siempre est\'a \textbf{a la derecha} del $aspersor_j$. Con esto en mente, la funci\'on principal (junto con sus auxiliares) es la siguiente: 
\newline
    %minimoCoste: Nat x Int --> Nat
\begin{equation}
 \label{funci\'on para el m\'inimo coste de aspersores}
 f(i,j) = \left\{
       \begin{array}{ll}
     0      & \mathrm{si\ } estaLleno(j) \\
     -1  & \mathrm{si\ } noSeLlenara(i,j) \\
     f(i+1,j)     & \mathrm{si\ } noSeLlenara(i+1,i) \\
     f(i+1,i) + costo(i)     & \mathrm{si\ } noSeLlenara(i+1,j) \\
     min((f(i+1,j), f(i+1,i) + costo(i))) & cc
       \end{array}
     \right.
\end{equation}

   % ANIMATE A PROCEDER QUE PEDAZO DE COMUNISTA LOKO JAJAJAJAJA ESTOY DANDO MI VIDA POR ESTE TP NO DUDO QUE TU DEMOSTRACION SERA FABULOSA VOY A ESO, QUE ME ESPERAN LOS SOCKETS DSPS GOOOOOD LA CLASE DE HOY PINTA PARA MASACRE, QUE LA DISFRUTEN LOS QUE VAN. DIOS NOS LIBRE

%noSeVaALlenar(i,j) = | True si (i = n and !estaLleno(j)) or noPuedoLlenarloAhora(i,j))
                         %| False si estaLleno(j)
                         %| noSeVaALlenar(i+1,j) or noSeVaALlenar(i+1,i)
\begin{equation}
 \label{funci\'on para ver si se va a llenar el terreno}
 noSeLlenara(i,j) = \left\{
       \begin{array}{ll}
     True      \phantom{aaaaaaa} \mathrm{si\ } (i = n \land \neg estaLleno(j)) \lor noPuedoLlenarlo(i,j)) \\
     False   \phantom{aaaaaal} \mathrm{si\ } estaLleno(j) \\
     noSeLlenara(i+1,j) \lor noSeLlenara(i+1,i) \phantom{aaaa}  \mathrm{cc\ }  \\
       \end{array}
     \right.
\end{equation}

\begin{equation}
 \label{funci\'on para ver si se puede llenar el terreno entre medio de los aspersores i,j}
 noPuedoLlenarlo(i,j) = limiteDerecho(aspersores_j) < limiteIzquierdo(aspersores_i). 
\end{equation}

\begin{equation}
 \label{funci\'on para ver si con el aspersor actual se cubre el final del terreno}
 estaLleno(j) = (l = 0) \or ((j \neq -1) \land \neg(limiteDerecho(aspersores_j) < l) 
\end{equation}


La funci\'on se resuelve con \textbf{f(0,-1)} y devuelve el m\'inimo coste de un conjunto de aspersores que pertenece a todos aquellos conjuntos de aspersores que riegan completamente el terreno. Es decir, si $\mathbb{O}$ = $\lbrace o_1,...,o_m  \rbrace$ la soluci\'on \'optima, siendo $\mathbb{S}$ el conjunto de soluciones posibles, entonces se tiene $\mathbb{O} \in \mathbb{S}$ / $f(0,-1)$ = $\sum_{i=1}^{|\mathbb{O}|}costo(o_{i})$.
\newline

Esta funcion tiene este comportamiento ya que existen dos casos, uno en el que el aspersor actual $a_i$ forma parte de un conjunto \'optimo $\mathbb{O}'$ de $r$ elementos, y otro donde no lo hace. Si forma parte, la soluci\'on al problema ser\'a $(\sum_{i=1}^{r-1}costo(o_{k}')) + costo(a_i)$. Mientras que si no lo hace, entonces el costo de la solucion optima $\mathbb{O}'$  de $r$ elementos es $\sum_{i=1}^{r}costo(o_{k}')$. Siempre y cuando exista ese \'optimo, lo elegiremos, mientras que si no hay soluci\'on al problema, es decir, el conjunto soluci\'on $\mathbb{S}$ est\'a vac\'io, se devolver\'a $-1$.  
\newline

Ahora bien, \textbf{¿vale la pena memoizar?} Si la funci\'on es correcta se puede simplemente programar y listo. El problema ya se resuelve. Sin embargo, el inconveniente que se presenta es que existe la superposici\'on de subproblemas en este algoritmo, ya que calculamos muchas veces instancias ya resueltas. Por esto mismo, empleamos \textbf{Programaci\'on Din\'amica}. Esto se debe a que la cantidad de llamados recursivos es $\Omega(2^{n}????????)$, mientras que la cantidad de subinstancias es ${O(n^2)}$. Por lo que presentamos una cantidad de llamadas exponencial mientras que las subinstancias son mucho menores al ser polinomial. Recordando que $n$ es la cantidad de aspersores \textit{v\'alidos}\footnote{Llamamos a un aspersor \textbf{v\'alido} si su di\'ametro de riego puede cubrir el ancho del terreno.} dentro del terreno.
\newline

Para la memoizaci\'on primero optamos por el enfoque \textbf{Top-Down}. Empleamos como estructura para guardar los datos ya calculados una matriz de $n+1 \times n+1$. Este algoritmo tiene una $complejidad$ $temporal$ y $espacial$ de $O(n^{2})$ (por la dimensi\'on de la matriz). Su pseudoc\'odigo es el siguiente:
\newline

% ME FALTA DE ACA PARA ABAJO!
\begin{algorithm}
\caption{menorCostoTopDown(A):}
\begin{algorithmic} 
\STATE Se inicializa M de $n+1 \times n+1$ con \bottom
\RETURN f(0,-1) tal que
\STATE \textbf{f(i,j):}
\IF{estaLleno(j)}
\RETURN 0
\ENDIF
\IF{noSeLlenara(i,j)}
\RETURN -1
\ENDIF
\IF{M[i,j] = \bottom}
\IF{noSeLlenara(i+1,i)}
\STATE M[i,j] \leftarrow f(i+1,j) 
\ENDIF
\ENDIF
\STATE $i \leftarrow 0$
\STATE $cubierto \leftarrow 0$
\STATE $minAspersores \leftarrow 0$
\RETURN $minAspersores$
\end{algorithmic}
\end{algorithm}
\newline

Luego fuimos por un enfoque \textbf{Bottom-Up} para poder comparar ambos m\'etodos y ver realmente cu\'al es el que ahorra m\'as tiempo de ejecuci\'on al eliminar pasos redundantes en el \'arbol recursivo. Se volvi\'o a disponer, en principio, de una matriz de $n+1 \times n+1$, pero en vez de tener un algoritmo \textbf{recursivo}, este es \textbf{iterativo}. Se itera a la matriz de \textit{izquierda a derecha} y de \textit{abajo a arriba}. Es decir, cuando estamos parados en una \textit{fila i}, la recorremos desde su $primera$ posici\'on hasta su $iésima$ posici\'on. Esto se repite partiendo desde la \textit{n+1-ésima fila} hasta la $primera$. Como en la funcion $f$ anteriormente mencionada el par\'ametro $i$ nunca es mas grande que el par\'ametro $j$, no se visitan aquellas celdas donde el n\'umero de la fila sea mayor al de la columna. Para finalizar con la explicaci\'on, el algoritmo queda con \textit{complejidad temporal y espacial O(n$^{2}$)} (por la matriz tambi\'en). Teniendo esto en mente, mostramos el algoritmo:
\newline

PSEUDOCODIGO
\newline

Al finalizar la implentaci\'on \textbf{Bottom-Up} notamos algo clave. Se puede \textit{ahorrar espacio} con la estructura de memoizaci\'on. No hace falta tener una matriz de $n+1 \times n+1$ para representar todas las soluciones, (tanto parciales como candidatas). Al no tener que reconstruir la soluci\'on ya que s\'olo se debe devolver el coste y no los aspersores que pertenecen al conjunto \'optimo, podemos \textbf{desechar la matriz} y tener como estructura de memoizaci\'on un \textbf{vector} de longitud $n+1$, guardando solamente la \textit{fila anteriormente calculada} y no todas las filas anteriores como suced\'ia con la matriz. Esto no mejora la \textit{complejidad temporal} pero s\'i la $espacial$, dej\'andola en $O(n)$ en vez de O(n$^{2}$). Una mejora considerable en utilizaci\'on de memoria. Su implementaci\'on qued\'o de la siguiente forma:
\newline

PSEUDOCODIGO
\newline

COMPARACION DE TIEMPOS DE EJECUCION ENTRE TOP-DOWN Y BOTTOM-UP PARA ELEGIR A UN GANADOR.
\newline

CONCLUSI\'ON

%% Hablar de por que la funcion funciona, luego del enfoque top down, despues el bottom up con matriz, y luego el bottom up sin matriz.